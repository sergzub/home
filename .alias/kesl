#export PATH=/usr/toolchain/x86_64-pc-linux-gnu_gcc4.8.3_glibc2.11/bin/:$PATH
#export PATH=/usr/toolchain/i686-pc-linux-gnu_gcc4.8.3_glibc2.11/bin/:$PATH

#export P4DIFF=vimdiff
#export P4USER=Zubkovsky
#export P4PORT=pf.avp.ru:1666
#export P4CONFIG=.p4config
#export P4EDITOR=mcedit


DATEFMT='+%FT%T%:z'
PRODUCT_NAME='kesl'

ChoosePrjName()
{
    case "$1" in
        'l'|'lmc')
            PRODUCT_NAME=lmc
            ;;
        'k'|'kesl')
            PRODUCT_NAME=kesl
            ;;
        *)
            PRODUCT_NAME=kesl
            ;;
    esac

    echo "====== '${PRODUCT_NAME}' project has been selected ======"
}

UpdatePrjtName()
{
    ChoosePrjName "$@"
    OUT_DIR_NAME=a.${PRODUCT_NAME}
    PRODUCT_OUT_DIR=~/work/${OUT_DIR_NAME}
}

kclic()
{
    if ln -sfT '/opt/kaspersky/kesl/doc/license.en' '/var/opt/kaspersky/kesl/private/agreed_eula.txt'; then
        echo 'Accepted'
    fi
}

isKavStarted()
{
    if [ $EUID -eq 0 ]; then
        echo "DO NOT do this under root user!!!"
        return 1;
    fi

    ps -ef | fgrep -v grep | fgrep --color=auto '/opt/kaspersky/${PRODUCT_NAME}/libexec/${PRODUCT_NAME}'
    if [ $? -eq 0 ]; then
        echo "The Product is started. Close it before run build."
        return 1; # kav stop
    fi
}

cmk_func()
{
    # isKavStarted || return $?;

    UpdatePrjtName "$@"

    local cfg="Debug"
    # if [ -z "${cfg}" ]; then
    #    cfg="Debug"
    # fi

    local OUTDIR="${PRODUCT_OUT_DIR}.${cfg}"
    if [ ! -d "${OUTDIR}" ]; then
        echo "'${OUTDIR}' does not exist"
        return 1;
    fi

    # -D LFS_PKG_PRODUCE_UNIQUE_VERSION_DIRECTORY:string=1
    (cd "${OUTDIR}" && cmake "-DCMAKE_BUILD_TYPE=${cfg}" -DSPLIT_SYMBOLS=1 "${OUTDIR}/../${PRODUCT_NAME}" 2>&1) | tee "${OUTDIR}/../cmake.log.$(date ${DATEFMT})"
}

mk_func()
{
    # isKavStarted || return $?;

    UpdatePrjtName "$@"

    local PRJS=("${@}")
    if [ ${#PRJS[@]} -eq 0 ]; then
       PRJS=(${PRODUCT_NAME}64.deb)
    fi

    local OUTDIR
    echo "PWD=$PWD"
    local l=$(basename "$PWD")
    l=${l%.*}
    if [ "$l" = "${OUT_DIR_NAME}" ]; then
        OUTDIR="$PWD"
        echo "====================== Building NON Debug =========================="
    else
        OUTDIR="${PRODUCT_OUT_DIR}.Debug"
        echo "====================== Building Debug =========================="
    fi

    cmake --build "${OUTDIR}" -- VERBOSE=1 -j2 "${PRJS[@]}" 2>&1 # | tee "${OUTDIR}/../make.log.$(date ${DATEFMT})"
}

alias cmk=cmk_func
alias mk=mk_func

alias mkc='mk Control64'
alias mkp='mk Product_bl64'

alias kav='sudo /etc/init.d/${PRODUCT_NAME}-supervisor'
alias kavs='/opt/kaspersky/${PRODUCT_NAME}/bin/${PRODUCT_NAME}-setup.pl'
alias kavas='sudo /opt/kaspersky/${PRODUCT_NAME}/bin/${PRODUCT_NAME}-setup.pl --autoinstall=${HOME}/work/autoinstall.ini'
alias kavp='sudo dpkg --purge ${PRODUCT_NAME}-dbg-unsigned'
alias kavi='sudo dpkg -i ${PRODUCT_OUT_DIR}/${PRODUCT_NAME}-dbg-unsigned_10.1.0-1_amd64.deb'
alias kavl='dpkg -l | fgrep kesl'

alias kl='/opt/kaspersky/klnagent/sbin/klnagent -tl 10 -tf "/var/log/kaspersky/klnagent/$(date '\''+%F %T%:z'\'').log"'
alias klk='killall klnagent'

alias frp='frp_func'
alias fr_only='fr_only_func'
alias f_only='f_only_func'
alias s_wc='~/work/zub/sync_wc bld ~/work/kesl'
alias cw='cd ~/work/kesl'

get_current_br()
{
    local br_Val=''
    br_Val=$(git rev-parse --abbrev-ref HEAD) || return $?
    echo "Current branch: ${br_Val}"
    if [ "${br_Val}" = 'master' ]; then
        echo '*** Do NOT work at the "master" branch directly! ***'
        # return 1
    fi

    eval "${1}='${br_Val}'"
}

f_only_func2()
{
    local br='$1'

    git fetch -v tfs 'refs/heads/master' || return $?
    echo "Fetching tfs/master: OK"
}

f_only_func()
{
    local br=''
    get_current_br br || return $?

    f_only_func2 "${br}" || return $?
}

fr_only_func()
{
    local br=''
    get_current_br br || return $?

    f_only_func2 "${br}" || return $?

    git rebase 'tfs/master' || return $?
    echo "Rebasing to tfs/master: OK"
}

frp_func()
{
    local br=''
    get_current_br br || return $?

    f_only_func2 "${br}" || return $?

    git rebase 'tfs/master' || return $?
    echo "Rebasing to tfs/master: OK"

    git push -v -u tfs "${br}" | git push -v --force-with-lease tfs "${br}" || return $?
    echo "Pushing to tfs: OK"
}

