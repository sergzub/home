IsVarSet() # checks if the variable is defined (or 'set' in term of SHELL)
{
    eval "[ \"\${${1}+isset}\" = 'isset' ]"
}

AssignAtVar()
{
    eval "${1#@}=\"\${2}\""
}

RemoveLagestPrefix()
{
    # verify that input variable ${1} exists
    eval : "\${${1}?RemoveLagestPrefix(): input variable is undefined}"

    eval "AssignAtVar \"\${3}\" \"\${${1}##\${2}}\""
}

RemoveLargestSuffix()
{
    # verify that input variable ${1} exists
    eval : "\${${1}?RemoveLargestSuffix(): input variable is undefined}"

    eval "AssignAtVar \"\${3}\" \"\${${1}%%\${2}}\""
}

Out()
{
    printf '%b' "$*"
}

OutErr()
{
    local titleTxt="${1}"
    shift
    Out "${titleTxt}: $*\n"
} 

# OutFmt()
# {
#     ???
# }

Echo()
{
    Out "$*\n"
}

DieRcFmt()
{
    local res="${1:?}"
    local fmt="${2:?}"

    if [ ! "${res}" -eq "${res}" ] 2>/dev/null; then
        DieFatal "illegal number '${res}' is used as exit code"
    fi

    local lvlTxt='ERROR'
    if [ "${res}" -lt 0 ]; then
        lvlTxt='FATAL'
        res=$((-${res}))
    elif [ "${res}" -eq 0 ]; then
        lvlTxt='WARNING'
    fi

    if [ "${res}" -lt 0 ] || [ "${res}" -gt 255 ]; then
        DieFatal "exit code '${res}' must be in interval [0; 255]"
    fi

    shift
    shift

    OutErr "\n${lvlTxt}" "$*\n" 1>&2

    if [ ${res} -ne 0 ]; then
        exit ${res}
    fi
}

DieRc()
{
    local res="${1:?}"
    shift
    DieRcFmt "${res}" "%s" "$@"
}

DieFmt()
{
    local fmt="${1:?}"
    shift
    DieRcFmt 1 "${fmt}" "$@"
}

Die()
{
    DieRc 1 "$@"
}

Warn()
{
    DieRc 0 "$@"
}

Fatal()
{
    DieRc -1 "$@"
}

DieIfRoot()
{
    if [ "${EUID}" -eq 0 ]; then
        Die "Don't run '$0' with the root privileges!!!"
    fi
}

# Getting non-clobbered output from command substitution
ExecCommand()
{
    # ${1}       -- output variable name
    # ${2}..{$n} -- command with arguments

    local s=''
    s="$(shift && { "$@"; } && printf '.')" || return $?
    AssignAtVar "${1}" "${s%.}"
}

ReadFile()
{
    # ${1} -- file to read
    # ${2} -- output variable name

    ExecCommand "${2}" "cat" "${1}"
}

# This function simply replaces every instance of «'» (single quote) within
# the string with «'\''» (single quote, backslash, single quote, single quote),
# then puts single quotes at the beginning and end of the string.
# Since the only character whose meaning is special within single quotes is
# the single quote character itself, this is totally safe.
# Trailing newlines are handled correctly, and the single quote at the end doubles
# as a safety character to prevent command substitution from clobbering
# the trailing newlines.
# See also: http://www.etalabs.net/sh_tricks.html
Quote()
{
    # ${1} -- input string
    # ${2} -- output variable name

    ExecCommand "${2}" 'printf' "%s\n" "${1}" "|" 'sed' "s:':'\\\\'':g;1s:^:':;\$s:\$:':"
}

# Check a given string in ${2} match a given filename (glob) pattern in ${1}
FnMatch()
{
    case "${2}" in
        ${1}) return 0 ;;
           *) return 1 ;;
    esac
}

# Function()
# {
#     local fn="${1:?}"

#     if type "${fn}" | grep -Fiq 'function'; then
#         Fatal "'${fn}' is already defined as function name"
#     fi

#     eval "${fn}()
#     {
#         local fn='${fn}'
#         Fatal \"call to undefined function '\${fn}'\"
#     }"
# }
